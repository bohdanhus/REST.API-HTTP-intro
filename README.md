# REST.API-HTTP-intro
https://metanit.com/web/nodejs/3.1.php
https://developer.mozilla.org/ru/docs/Learn/Server-side/First_steps/Client-Server_overview
What is REST#
Representative State Transfer
Convention over HTTP
Key characteristics#

-----------------------------------------------------------------------------------------------
Resource based (server pages, records in database)

Use URLs as unique identifiers

Stateless ("session" state transferred in request/response and not hold on server side)

Common representations: HTML, XML, JSON

HTTP usage#
-----------------------------------------------------------------------------------------------
resource identifier – HTTP path (/posts, /tasks/42, /posts/123/comments)

action – HTTP method (GET, POST, PUT, PATCH, DELETE, HEAD)

resource representation (JSON, HTML) – request and/or response body

meta information – headers (authentication, caching, content type)

action result status – HTTP status codes

HTTP method mapping to actions against resource#
-----------------------------------------------------------------------------------------------
GET – get

POST - create

PUT – replace

PATCH – partial update

DELETE – delete

Common status codes#
-----------------------------------------------------------------------------------------------
200 OK

201 Created

400 Bad request (malformed body)

401 Not authenticated

403 Not authorized

404 Resource not found

422 Unprocessable entity (server side validation failed)

500 Internal server error




Веб-браузеры взаимодействуют с веб-серверами при помощи протокола передачи гипертекста (HTTP). Когда вы кликаете на ссылку на странице, заполняете форму или производите поиск, браузер отправляет на сервер HTTP-запрос.

Этот запрос включает:

Путь (URL), который определяет целевой сервер и ресурс (например, HTML-файл, конкретная точка данных на сервере или запускаемый инструмент).
Метод, который определяет необходимое действие (например, получить файл, сохранить или обновить какие-либо данные). Различные методы/команды и связанные с ними действия перечислены ниже:
GET – получить определённый ресурс (например, HTML-файл, содержащий информацию о товаре или список товаров).
POST – создать новый ресурс (например, добавить новую статью на вики, добавить новый контакт в базу данных).
HEAD – получить метаданные об определённом ресурсе без получения содержания, как это делает запрос GET. Например, вы можете использовать запрос HEAD, чтобы узнать, когда ресурс в последний раз обновлялся, и только потом использовать (более «затратный») запрос GET, чтобы загрузить сам ресурс, если он был изменён.
PUT – обновить существующий ресурс (или создать новый, если таковой не существует).
DELETE – удалить определённый ресурс.
TRACE, OPTIONS, CONNECT, PATCH – эти команды используются для менее популярных/более сложных задач, поэтому пока мы не будем их рассматривать.
Дополнительная информация может быть закодирована в запросе (например, данные HTML-формы). Информация может быть закодирована как:
URL-параметры: GET запросы зашифровывают данные в URL-адресе, который отправляется на сервер, путём добавления пар имя/значение в его конец, например, http://mysite.com?name=Fred&age=11. В этом случае всегда ставится знак вопроса (?), отделяющий основную часть URL-адреса от URL-параметров, знак равно (=), отделяющий каждое имя от соответствующего ему значения, и амперсанд (&), разделяющий пары. URL-параметры, по своей сути, «небезопасны», так как могут быть изменены пользователями и затем отправлены повторно. В результате, URL-параметры /GET запросы не используются для запросов, которые обновляют данные на сервере.
POST данные. POST запросы добавляют новые ресурсы, данные которых зашифрованы в теле самого запроса.
Куки-файлы клиентской части. Куки-файлы содержат данные сессий о клиенте, включая ключи, которые сервер может использовать для определения статуса его авторизации и разрешения/права доступа к ресурсам.
Веб-серверы ожидают сообщений с запросами от клиентов, обрабатывают их, когда они приходят и отвечают веб-браузеру через сообщение с HTTP-ответом. Ответ содержит Код статуса HTTP-ответа, который показывает, был ли запрос успешным (например, «200 OK» означает успех, «404 Not Found» если ресурс не может быть найден, «403 Forbidden», если пользователь не имеет права просматривать ресурс, и т. д.). Тело успешного ответа на запрос GET будет содержать запрашиваемый ресурс.

После того как HTML-страница возвращена, она отрисовывается браузером. Во время этого браузер может обнаружить ссылки на другие ресурсы (например, HTML-страница обычно ссылается на JavaScript и CSS-файлы) и послать отдельные HTTP-запросы для загрузки этих файлов.

Как статические, так и динамические веб-сайты (речь о которых идёт в следующих разделах) используют точно такой же протокол/шаблоны обмена данными.

Пример GET запроса/ответа
Вы можете сформировать простой GET запрос кликнув по ссылке или через поиск по сайту (такой как страница поисковой системы). Например, HTTP-запрос, отправленный во время выполнения запроса "client server overview" на сайте MDN, будет во многом похож на текст ниже (он не будет идентичным, потому что части сообщения зависят от вашего браузера/настроек).

Формат HTTP сообщения определён в «веб-стандарте» (RFC7230). Вам не нужно знать этот уровень детализации, но, по крайней мере, теперь вы знаете, откуда это появилось!

Запрос
Каждая строка запроса содержит информацию о запросе. Первая часть называется заголовок и содержит важную информацию о запросе, точно так же, как HTML head содержит важную информацию о HTML-документе (но не содержимое документа, которое расположено внутри тэга "body"):

GET https://developer.mozilla.org/en-US/search?q=client+server+overview&topic=apps&topic=html&topic=css&topic=js&topic=api&topic=webdev HTTP/1.1
Host: developer.mozilla.org
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Referer: https://developer.mozilla.org/en-US/
Accept-Encoding: gzip, deflate, sdch, br
Accept-Language: en-US,en;q=0.8,es;q=0.6
Cookie: sessionid=6ynxs23n521lu21b1t136rhbv7ezngie; csrftoken=zIPUJsAZv6pcgCBJSCj1zU6pQZbfMUAT; dwf_section_edit=False; dwf_sg_task_completion=False; _gat=1; _ga=GA1.2.1688886003.1471911953; ffo=true
Первая и вторая строки содержат большую часть информации, о которой говорилось выше:

Тип запроса (GET).
URL целевого ресурса (/en-US/search).
URL-параметры (q=client%2Bserver%2Boverview&topic=apps&topic=html&topic=css&topic=js&topic=api&topic=webdev).
Целевой/хост-веб-сайт (developer.mozilla.org).
Конец первой строки также содержит короткую строку, идентифицирующую версию протокола (HTTP/1.1).
Последняя строка содержит информацию о клиентских куки — в данном случае можно увидеть куки, включающие id для управления сессиями (Cookie: sessionid=6ynxs23n521lu21b1t136rhbv7ezngie; ...).

Оставшиеся строки содержат информацию об используемом браузере и о видах ответов, которые он может обработать. Например, здесь вы можете увидеть:

Мой браузер (User-Agent) — Mozilla Firefox (Mozilla/5.0).
Он может принимать информацию, упакованную в gzip (Accept-Encoding: gzip).
Он может принимать указанные кодировки  (Accept-Charset: ISO-8859-1,UTF-8;q=0.7,*;q=0.7) и языков (Accept-Language: de,en;q=0.7,en-us;q=0.3).
Строка Referer идентифицирует адрес веб-страницы, содержащей ссылку на этот ресурс (то есть источник оригинального запроса, https://developer.mozilla.org/en-US/).
HTTP-запрос может также содержать body, но в данном случае этого нет.

Ответ
Первая часть ответа на запрос показана ниже. Заголовок содержит следующую информацию:

Первая строка содержит код ответа 200 OK, говорящий о том, что запрос выполнен успешно.
Мы можем видеть, что ответ имеет text/html формат (Content-Type).
Также мы видим, что ответ использует кодировку UTF-8 (Content-Type: text/html; charset=utf-8).
Заголовок также содержит длину ответа (Content-Length: 41823).
В конце сообщения мы видим содержимое body, содержащее HTML-код возвращаемого ответа.

HTTP/1.1 200 OK
Server: Apache
X-Backend-Server: developer1.webapp.scl3.mozilla.com
Vary: Accept,Cookie, Accept-Encoding
Content-Type: text/html; charset=utf-8
Date: Wed, 07 Sep 2016 00:11:31 GMT
Keep-Alive: timeout=5, max=999
Connection: Keep-Alive
X-Frame-Options: DENY
Allow: GET
X-Cache-Info: caching
Content-Length: 41823



<!DOCTYPE html>
<html lang="en-US" dir="ltr" class="redesign no-js"  data-ffo-opensanslight=false data-ffo-opensans=false >
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <script>(function(d) { d.className = d.className.replace(/\bno-js/, ''); })(document.documentElement);</script>
  ...
Copy to Clipboard
Остальная часть заголовка ответа содержит информацию об ответе (например, когда он был сгенерирован), сервере и о том, как он ожидает, что браузер обработает страницу (например, строка X-Frame-Options: DENY говорит браузеру не допускать внедрения этой страницы, если она будет внедрена в <iframe> (en-US) на другом сайте).

Пример POST запроса/ответа
HTTP POST создаётся, когда вы отправляете форму, содержащую информацию, которая должна быть сохранена на сервере.

Запрос
В приведённом ниже тексте показан HTTP-запрос, сделанный когда пользователь загружает новые данные профиля на этом сайте. Формат запроса почти такой же, как пример запроса GET, показанный ранее, хотя первая строка идентифицирует этот запрос как POST.

POST https://developer.mozilla.org/en-US/profiles/hamishwillee/edit HTTP/1.1
Host: developer.mozilla.org
Connection: keep-alive
Content-Length: 432
Pragma: no-cache
Cache-Control: no-cache
Origin: https://developer.mozilla.org
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Referer: https://developer.mozilla.org/en-US/profiles/hamishwillee/edit
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.8,es;q=0.6
Cookie: sessionid=6ynxs23n521lu21b1t136rhbv7ezngie; _gat=1; csrftoken=zIPUJsAZv6pcgCBJSCj1zU6pQZbfMUAT; dwf_section_edit=False; dwf_sg_task_completion=False; _ga=GA1.2.1688886003.1471911953; ffo=true

csrfmiddlewaretoken=zIPUJsAZv6pcgCBJSCj1zU6pQZbfMUAT&user-username=hamishwillee&user-fullname=Hamish+Willee&user-title=&user-organization=&user-location=Australia&user-locale=en-US&user-timezone=Australia%2FMelbourne&user-irc_nickname=&user-interests=&user-expertise=&user-twitter_url=&user-stackoverflow_url=&user-linkedin_url=&user-mozillians_url=&user-facebook_url=
Copy to Clipboard
Основное различие заключается в том, что URL-адрес не имеет параметров. Как вы можете видеть, информация из формы закодирована в теле запроса (например, новое полное имя пользователя устанавливается с использованием: &user-fullname=Hamish+Willee).

Ответ
Ответ от запроса показан ниже. Код состояния «302 Found» сообщает браузеру, что сообщение обработано, и что необходим второй HTTP-запрос для загрузки страницы, указанной в поле Location. В остальном информация аналогична информации для ответа на запрос GET .

HTTP/1.1 302 FOUND
Server: Apache
X-Backend-Server: developer3.webapp.scl3.mozilla.com
Vary: Cookie
Vary: Accept-Encoding
Content-Type: text/html; charset=utf-8
Date: Wed, 07 Sep 2016 00:38:13 GMT
Location: https://developer.mozilla.org/en-US/profiles/hamishwillee
Keep-Alive: timeout=5, max=1000
Connection: Keep-Alive
X-Frame-Options: DENY
X-Cache-Info: not cacheable; request wasn't a GET or HEAD
Content-Length: 0
Copy to Clipboard
На заметку: HTTP-ответы и запросы, показанные в этих примерах, были захвачены с помощью приложения Fiddler, но вы можете получить аналогичную информацию с помощью веб-снифферов (например, http://web-sniffer.net/) или с помощью расширений браузера, таких как HttpFox. Вы можете попробовать это сами. Воспользуйтесь любым из предложенных инструментов, а затем перейдите по сайту и отредактируйте информацию профиля, чтобы увидеть различные запросы и ответы. В большинстве современных браузеров также есть инструменты, которые отслеживают сетевые запросы (например, инструмент Network Monitor в Firefox).

Статические сайты
Статический сайт — это тот, который возвращает тот же жёсткий кодированный контент с сервера всякий раз, когда запрашивается конкретный ресурс. Например, если у вас есть страница о товаре в /static/myproduct1.html, эта же страница будет возвращена каждому пользователю. Если вы добавите ещё один подобный товар на свой сайт, вам нужно будет добавить ещё одну страницу (например, myproduct2.html) и так далее. Это может стать действительно неэффективным — что происходит, когда вы попадаете на тысячи страниц товаров? Вы повторяли бы много кода на каждой странице (основной шаблон страницы, структуру и т. д.), И если бы вы захотели изменить что-либо в структуре страницы — например, добавить новый раздел «связанные товары» — тогда вам придётся менять каждую страницу отдельно.

На заметку: Статические сайты превосходны, когда у вас небольшое количество страниц и вы хотите отправить один и тот же контент каждому пользователю. Однако их обслуживание может потребовать значительных затрат по мере увеличения количества страниц.

Давайте вспомним, как это работает, снова взглянув на диаграмму архитектуры статического сайта, на которую мы смотрели в последней статье.

A simplified diagram of a static web server.

Когда пользователь хочет перейти на страницу, браузер отправляет HTTP-запрос GET с указанием URL-адреса его HTML-страницы. Сервер извлекает запрошенный документ из своей файловой системы и возвращает HTTP-ответ, содержащий документ и код состояния HTTP Response status code 200 OK (успех). Сервер может вернуть другой код состояния, например, «404 Not Found», если файл отсутствует на сервере или «301 Moved Permanently», если файл существует, но был перемещён в другое место.

Серверу для статического сайта нужно будет только обрабатывать GET-запросы, потому что сервер не сохраняет никаких модифицируемых данных. Он также не изменяет свои ответы на основе данных HTTP-запроса (например, URL-параметров или файлов cookie).

Понимание того, как работают статические сайты, тем не менее полезно при изучении программирования на стороне сервера, поскольку динамические сайты точно так же обрабатывают запросы для статических файлов (CSS, JavaScript, статические изображения и т. д.).

Динамические сайты
Динамический сайт — это тот, который может генерировать и возвращать контент на основе конкретного URL-адреса запроса и данных (а не всегда возвращать один и тот же жёсткий код для определённого URL-адреса). Используя пример сайта товара, сервер будет хранить «данные» товара в базе данных, а не отдельные HTML-файлы. При получении GET-запроса для товара сервер определяет идентификатор товара, извлекает данные из базы данных и затем создаёт HTML-страницу для ответа, вставляя данные в HTML-шаблон. Это имеет большие преимущества перед статическим сайтом:

Использование базы данных позволяет эффективно хранить информацию о товаре с помощью легко расширяемого, изменяемого и доступного для поиска способа.

Использование HTML-шаблонов позволяет очень легко изменить структуру HTML, потому что это нужно делать только в одном месте, в одном шаблоне, а не через потенциально тысячи статических страниц.

Анатомия динамического запроса
В этом разделе представлен пошаговый обзор «динамического» цикла HTTP-запроса и ответа, основываясь на том, что мы рассмотрели в последней статье, с гораздо более подробной информацией. Чтобы не отдаляться от практики, мы будем использовать контекст веб-сайта менеджера спортивной команды, где тренер может выбрать имя своей команды и размер команды в HTML-форме и вернуться к предлагаемому «лучшему составу» для своей следующей игры.

На приведённой ниже диаграмме показаны основные элементы веб-сайта «team coach», а также пронумерованные ярлыки для последовательности операций, когда тренер обращается к списку «лучших команд». Частями сайта, которые делают его динамичным, являются веб-приложение (так мы будем ссылаться на серверный код, обрабатывающий HTTP-запросы и возвращающие HTTP-ответы), база данных, которая содержит информацию об игроках, командах, тренерах и их отношениях, и HTML-шаблоны.

This is a diagram of a simple web server with step numbers for each of step of the client-server interaction.

После того, как тренер отправит форму с именем команды и количеством игроков, последовательность операций будет следующей:

Веб-браузер отправит HTTP-запрос GET на сервер с использованием базового URL-адреса ресурса (/best) и кодирования номера команды и игрока в форме URL-параметров (например, /best?team=my_team_name&show=11) или как часть URL-адреса (например, /best/my_team_name/11/). Запрос GET используется, потому что речь идёт только о запросе выборки данных (а не об их изменении).
Веб-сервер определяет, что запрос является «динамическим» и пересылает его в веб-приложение для обработки (веб-сервер определяет, как обрабатывать разные URL-адреса на основе правил сопоставления шаблонов, определённых в его конфигурации).
Веб-приложение определяет, что цель запроса состоит в том, чтобы получить «лучший список команд» на основе URL (/best/) и узнать имя команды и количество игроков из URL-адреса. Затем веб-приложение получает требуемую информацию из базы данных (используя дополнительные «внутренние» параметры, чтобы определить, какие игроки являются «лучшими», и, возможно, определяя личность зарегистрированного тренера из файла cookie на стороне клиента).
Веб-приложение динамически создаёт HTML-страницу, помещая данные (из базы данных) в заполнители внутри HTML-шаблона.
Веб-приложение возвращает сгенерированный HTML в веб-браузер (через веб-сервер) вместе с кодом состояния HTTP 200 («успех»). Если что-либо препятствует возврату HTML, веб-приложение вернёт другой код, например, «404», чтобы указать, что команда не существует.
Затем веб-браузер начнёт обрабатывать возвращённый HTML, отправив отдельные запросы, чтобы получить любые другие файлы CSS или JavaScript, на которые он ссылается (см. шаг 7).
Веб-сервер загружает статические файлы из файловой системы и возвращает их непосредственно в браузер (опять же, правильная обработка файлов основана на правилах конфигурации и сопоставлении шаблонов URL).
Операция по обновлению записи в базе данных будет обрабатываться аналогичным образом, за исключением того, что, как и любое обновление базы данных, HTTP-запрос из браузера должен быть закодирован как запрос POST.
  
  
Анатомия HTTP-транзакции
Цель этого руководства - дать четкое представление о процессе обработки HTTP-запросов в Node.js. Мы предполагаем, что вы знаете, в общем смысле, как работают HTTP-запросы, независимо от языка или среды программирования. Мы также предполагаем, что немного знакомы с Node.js EventEmittersи Streams. Если вы не совсем знакомы с ними, стоит быстро прочитать документацию по API для каждого из них.

Создать сервер
Любое приложение веб-сервера узла в какой-то момент должно будет создать объект веб-сервера. Это делается с помощью createServer.

const http = require('http');

const server = http.createServer((request, response) => {
  // magic happens here!
});
Переданная функция createServerвызывается один раз для каждого HTTP-запроса, отправляемого к этому серверу, поэтому она называется обработчиком запросов. Фактически, Serverобъект, возвращаемый функцией, createServer- это EventEmitterпросто сокращение для создания serverобъекта и последующего добавления слушателя.

const server = http.createServer();
server.on('request', (request, response) => {
  // the same kind of magic happens here!
});
Когда HTTP-запрос попадает на сервер, узел вызывает функцию обработчика запросов с несколькими удобными объектами для работы с транзакцией, requestи response. Мы вернемся к ним в ближайшее время.

Чтобы действительно обслуживать запросы, listenнеобходимо вызвать метод serverобъекта. В большинстве случаев все, что вам нужно будет передать, listen- это номер порта, который должен прослушивать сервер. Есть и другие варианты, поэтому обратитесь к справочнику по API .

Метод, URL и заголовки
При обработке запроса первое, что вы, вероятно, захотите сделать, это посмотреть на метод и URL-адрес, чтобы можно было предпринять соответствующие действия. Node.js делает это относительно безболезненным, добавляя в requestобъект удобные свойства .

const { method, url } = request;
requestОбъект является экземпляром IncomingMessage.

methodЗдесь всегда будет нормальный метод HTTP / глагол. Это urlполный URL-адрес без сервера, протокола или порта. Для типичного URL-адреса это означает все, что находится после третьей косой черты, включая ее.

Заголовки тоже не за горами. Они находятся в своем собственном объекте по requestвызову headers.

const { headers } = request;
const userAgent = headers['user-agent'];
Здесь важно отметить, что все заголовки представлены только в нижнем регистре, независимо от того, как клиент их фактически отправил. Это упрощает задачу синтаксического анализа заголовков для любых целей.

Если некоторые заголовки повторяются, их значения перезаписываются или объединяются как строки, разделенные запятыми, в зависимости от заголовка. В некоторых случаях это может быть проблематично, поэтому rawHeadersтакже доступно.

Тело запроса
При получении запроса POSTили PUTтело запроса может быть важным для вашего приложения. Получение данных тела немного сложнее, чем доступ к заголовкам запроса. requestОбъект , который передается в обработчику реализует ReadableStreamинтерфейс. Этот поток можно прослушивать или передавать по конвейеру в другом месте, как и любой другой поток. Мы можем получить данные прямо из потока, прослушивая потоки 'data'и 'end'события.

Чанк, генерируемый в каждом 'data'событии, - это файл Buffer. Если вы знаете, что это будут строковые данные, лучше всего собрать данные в массив, а затем 'end'объединить и преобразовать их в строку.

let body = [];
request.on('data', (chunk) => {
  body.push(chunk);
}).on('end', () => {
  body = Buffer.concat(body).toString();
  // at this point, `body` has the entire request body stored in it as a string
});
Это может показаться немного утомительным, и во многих случаях это так. К счастью, существуют модули , как concat-streamи bodyна npmкоторые могут помочь скрыть от некоторых из этой логики. Важно хорошо понимать, что происходит, прежде чем идти по этому пути, и именно поэтому вы здесь!

Немного об ошибках
Поскольку requestобъект является объектом a ReadableStream, он также является объектом EventEmitterи ведет себя как объект при возникновении ошибки.

Ошибка в requestпотоке проявляется в передаче 'error'события в потоке. Если у вас нет слушателя для этого события, будет выдана ошибка , которая может привести к сбою вашей программы Node.js. Поэтому вам следует добавить 'error'слушателя в потоки запросов, даже если вы просто зарегистрируете его и продолжите свой путь. (Хотя, вероятно, лучше всего отправить ответ об ошибке HTTP. Подробнее об этом позже.)

request.on('error', (err) => {
  // This prints the error message and stack trace to `stderr`.
  console.error(err.stack);
});
Есть и другие способы обработки этих ошибок, такие как другие абстракции и инструменты, но всегда помните, что ошибки могут и случаются, и вам придется иметь дело с ними.

Что мы зашли так далеко
На этом этапе мы рассмотрели создание сервера и извлечение метода, URL, заголовков и тела из запросов. Когда мы сложим все это вместе, это может выглядеть примерно так:

const http = require('http');

http.createServer((request, response) => {
  const { headers, method, url } = request;
  let body = [];
  request.on('error', (err) => {
    console.error(err);
  }).on('data', (chunk) => {
    body.push(chunk);
  }).on('end', () => {
    body = Buffer.concat(body).toString();
    // At this point, we have the headers, method, url and body, and can now
    // do whatever we need to in order to respond to this request.
  });
}).listen(8080); // Activates this server, listening on port 8080.
Если мы запустим этот пример, мы сможем получать запросы, но не отвечать на них. Фактически, если вы нажмете этот пример в веб-браузере, ваш запрос истечет по тайм-ауту, так как ничего не отправляется обратно клиенту.

До сих пор мы вообще не касались responseобъекта, который является экземпляром ServerResponse, которым является WritableStream. Он содержит множество полезных методов для отправки данных обратно клиенту. Мы поговорим об этом позже.

Код состояния HTTP
Если вы не потрудитесь установить его, код состояния HTTP в ответе всегда будет 200. Конечно, не каждый ответ HTTP гарантирует это, и в какой-то момент вы определенно захотите отправить другой код состояния. Для этого вы можете установить statusCodeсвойство.

response.statusCode = 404; // Tell the client that the resource wasn't found.
Как мы скоро увидим, есть и другие ярлыки.

Установка заголовков ответа
Заголовки устанавливаются с помощью удобного метода, называемого setHeader.

response.setHeader('Content-Type', 'application/json');
response.setHeader('X-Powered-By', 'bacon');
При установке заголовков в ответ регистр не зависит от их имен. Если вы устанавливаете заголовок несколько раз, последнее значение, которое вы устанавливаете, является значением, которое будет отправлено.

Явная отправка данных заголовка
Методы установки заголовков и кода состояния, которые мы уже обсуждали, предполагают, что вы используете «неявные заголовки». Это означает, что вы рассчитываете, что узел отправит вам заголовки в нужное время, прежде чем вы начнете отправлять данные тела.

Если хотите, вы можете явно записать заголовки в поток ответа. Для этого вызывается метод writeHead, который записывает код состояния и заголовки в поток.

response.writeHead(200, {
  'Content-Type': 'application/json',
  'X-Powered-By': 'bacon'
});
После того, как вы установили заголовки (явно или неявно), вы готовы начать отправку данных ответа.

Отправка тела ответа
Поскольку responseобъект является a WritableStream, написание тела ответа клиенту - это просто вопрос использования обычных потоковых методов.

response.write('<html>');
response.write('<body>');
response.write('<h1>Hello, World!</h1>');
response.write('</body>');
response.write('</html>');
response.end();
endФункция на потоках может также принимать в некоторых дополнительных данных для передачи в качестве последнего бита данных о потоке, таким образом , мы можем упростить пример выше следующим образом .

response.end('<html><body><h1>Hello, World!</h1></body></html>');
Важно установить статус и заголовки до того, как вы начнете записывать фрагменты данных в тело. Это имеет смысл, поскольку в HTTP-ответах заголовки идут перед телом.

Еще одна небольшая мысль об ошибках
responseПоток также может испускать 'error'события, и в какой - то момент вы будете иметь дело с этим , а также. Все советы по поводу requestошибок потока применимы и здесь.

Положил все это вместе
Теперь, когда мы узнали об отправке HTTP-ответов, давайте соберем все это воедино. Основываясь на предыдущем примере, мы собираемся создать сервер, который отправляет обратно все данные, которые были отправлены нам пользователем. Мы отформатируем эти данные как JSON, используя JSON.stringify.

const http = require('http');

http.createServer((request, response) => {
  const { headers, method, url } = request;
  let body = [];
  request.on('error', (err) => {
    console.error(err);
  }).on('data', (chunk) => {
    body.push(chunk);
  }).on('end', () => {
    body = Buffer.concat(body).toString();
    // BEGINNING OF NEW STUFF

    response.on('error', (err) => {
      console.error(err);
    });

    response.statusCode = 200;
    response.setHeader('Content-Type', 'application/json');
    // Note: the 2 lines above could be replaced with this next one:
    // response.writeHead(200, {'Content-Type': 'application/json'})

    const responseBody = { headers, method, url, body };

    response.write(JSON.stringify(responseBody));
    response.end();
    // Note: the 2 lines above could be replaced with this next one:
    // response.end(JSON.stringify(responseBody))

    // END OF NEW STUFF
  });
}).listen(8080);
Пример эхо-сервера
Давайте упростим предыдущий пример, чтобы создать простой эхо-сервер, который просто отправляет все данные, полученные в запросе, обратно в ответ. Все, что нам нужно сделать, это взять данные из потока запроса и записать эти данные в поток ответов, как мы делали ранее.

const http = require('http');

http.createServer((request, response) => {
  let body = [];
  request.on('data', (chunk) => {
    body.push(chunk);
  }).on('end', () => {
    body = Buffer.concat(body).toString();
    response.end(body);
  });
}).listen(8080);
Теперь давайте подправим это. Мы хотим отправлять эхо только при следующих условиях:

Метод запроса - POST.
URL-адрес /echo.
В любом другом случае мы просто хотим ответить 404.

const http = require('http');

http.createServer((request, response) => {
  if (request.method === 'POST' && request.url === '/echo') {
    let body = [];
    request.on('data', (chunk) => {
      body.push(chunk);
    }).on('end', () => {
      body = Buffer.concat(body).toString();
      response.end(body);
    });
  } else {
    response.statusCode = 404;
    response.end();
  }
}).listen(8080);
Проверяя URL таким образом, мы выполняем своего рода «маршрутизацию». Другие формы маршрутизации могут быть как простыми, как switchоператоры, так и сложными, например, целыми фреймворками express. Если вы ищете что-то, что выполняет маршрутизацию, и ничего больше, попробуйте router.

Большой! Теперь давайте попробуем упростить это. Помните, что requestобъект - это a, ReadableStreamа responseобъект - это WritableStream. Это означает, что мы можем использовать pipeдля перенаправления данных от одного к другому. Это именно то, что нам нужно для эхо-сервера!

const http = require('http');

http.createServer((request, response) => {
  if (request.method === 'POST' && request.url === '/echo') {
    request.pipe(response);
  } else {
    response.statusCode = 404;
    response.end();
  }
}).listen(8080);
Ура стримы!

Однако мы еще не закончили. Как неоднократно упоминалось в этом руководстве, ошибки могут происходить и случаются, и нам необходимо с ними бороться.

Чтобы обрабатывать ошибки в потоке запроса, мы регистрируем ошибку stderrи отправляем код состояния 400, чтобы указать Bad Request. Однако в реальном приложении мы хотели бы проверить ошибку, чтобы выяснить, каким будет правильный код состояния и сообщение. Как обычно при ошибках, вам следует обратиться к Errorдокументации .

В ответ мы просто зарегистрируем ошибку в stderr.

const http = require('http');

http.createServer((request, response) => {
  request.on('error', (err) => {
    console.error(err);
    response.statusCode = 400;
    response.end();
  });
  response.on('error', (err) => {
    console.error(err);
  });
  if (request.method === 'POST' && request.url === '/echo') {
    request.pipe(response);
  } else {
    response.statusCode = 404;
    response.end();
  }
}).listen(8080);
Мы рассмотрели большинство основ обработки HTTP-запросов. На этом этапе вы должны уметь:

Создайте экземпляр HTTP-сервера с функцией обработчика запросов и попросите его прослушивать порт.
Получайте заголовки, URL, данные метода и тела от requestобъектов.
Принимайте решения о маршрутизации на основе URL-адреса и / или других данных в requestобъектах.
Отправляйте заголовки, коды состояния HTTP и данные тела через responseобъекты.
Передача данных от requestобъектов к responseобъектам.
Обработка ошибок потока как в потоках, так requestи в responseпотоках.
На основе этих основ можно создать HTTP-серверы Node.js для многих типичных случаев использования. Есть много других вещей , эти интерфейсы обеспечивают, так что не забудьте прочитать через API документации для EventEmitters, Streamsи HTTP.
